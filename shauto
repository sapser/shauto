#!/bin/bash
#
#shell运维自动化工具


#引用未定义的变量时报错并退出脚本
set -o nounset
#命令执行失败时报错并退出脚本
#set -o errexit

#脚本所在目录的绝对路径
SCRIPT_DIR="$(cd $(dirname $0);pwd)"
#脚本绝对路径
SCRIPT_PATH="${SCRIPT_DIR}/$(basename $0)"
#hosts文件默认路径
HOSTS_FILE="hosts"
#临时保存数据目录
TEMP_DIR="/tmp/$(basename $0)_temp_dir"

#要执行的模块
MODULE=""
#模块参数
MODULE_ARGS=""
#执行自定义脚本文件
BATCH_FILE=""

#远程ssh用户
REMOTE_USER="chenwei" 
#远程ssh端口
REMOTE_PORT=22
#远程shell
REMOTE_SHELL="bash"
#私钥
PRIVATE_KEY_FILE=""
#ssh连接超时时间
TIMEOUT=10
#ssh连接选项
#SSH_ARGS="-o StrictHostKeyChecking=no -o ConnectTimeout=${TIMEOUT}"
SSH_ARGS="-o StrictHostKeyChecking=no"
#并发数量
FORKS=5

#要执行命令的主机列表
HOSTLIST=()
#主机匹配模式
PATTERN=""
#要执行的命令
CMDLIST="set -o errexit"
#冗余模式
VERBOSE=""


usage() {
    cat <<EOF
Usage: $(basename $0) <host-pattern> [option]...

Options:
  -a
  -m
  -u
  -p
EOF
    
    exit 1
}


success() {
    echo -e "\033[32m$@\033[0m"
}


failed() {
    echo -e "\033[31m$@\033[0m" >&2
}


error() {
    echo -e "\033[31m$@\033[0m" >&2
    exit 1
}


#创建临时目录，保存执行结果
create_temp_dir() {
    [[ -d "$TEMP_DIR" ]] && rm -rf "$TEMP_DIR" &>/dev/null
    mkdir -m 700 $TEMP_DIR
}


hostfile_check() {
    :
}


#解析hosts文件
hostfile_parse() {
    [[ -f "$HOSTS_FILE" ]] || error "$HOSTS_FILE does not exist!"

    #hostfile语法检测
    #hostfile_check

    if grep "^\[$PATTERN\]" "$HOSTS_FILE" &>/dev/null; then
        #匹配组
        local match_hosts="$(sed -n "/^\[$PATTERN\]/,/^\[/p" "$HOSTS_FILE" | sed '/^\[/d' | sort | uniq)"
        local host=""
        for host in $match_hosts; do
            #向数组添加元素
            HOSTLIST+=("$host")
        done
    elif [[ "$PATTERN" =~ ^[1-9][0-9]*\.[0-9]+\.[0-9]+\.[0-9]+$ ]] \
        && grep "^$PATTERN" "$HOSTS_FILE" &>/dev/null; then
        #匹配单个IP
        HOSTLIST+=("$PATTERN")
    elif [[ "$PATTERN" == "all" || "$PATTERN" == "*" ]]; then
        #匹配所有主机
        local match_hosts="$(grep '^[1-9]' "$HOSTS_FILE" | sort | uniq)"
        local host=""
        for host in $match_hosts; do
            HOSTLIST+=("$host")
        done
    else
        error "$PATTERN does not match any host in $HOSTS_FILE"
    fi
}


#管理文件/目录属性
#Usage: attrib [option]... path
#Options:
#  -u owner: 属主，可选，默认值"$REMOTE_USER"
#  -g group: 属组，可选，默认值"$REMOTE_USER"
#  -m mode: 权限，可选，默认值"0644"
#  -r/-R: 是否递归处理目录，可选，默认不递归处理目录
attrib() {
    local owner="$REMOTE_USER"
    local group="$owner"
    local mode="0644"
    local recursive=""

    while getopts :u:g:m:rR option; do
        case "$option" in
            u) owner="$OPTARG";;
            g) group="$OPTARG";;
            m) mode="$OPTARG";;
            r|R) recursive="-R";;
            \?) error "attrib: invalid option -${OPTARG}";;
            \:) error "attrib: must provide a value for -${OPTARG} option";;
        esac
    done
    #处理完选项，$1变为非选项参数
    shift $(($OPTIND - 1)) 
    unset OPTIND

    [[ -n "$1" ]] || error "attrib: must specify a path"
    CMDLIST="$CMDLIST
chmod $recursive $mode $@ && chown $recursive ${owner}:${group} $@"
}


#传输文件/目录到远程主机
scp_file() {
    :
}


#连接远程主机并执行命令
ssh_cmd() {
    local host="$1"
    local temp_file_success="${TEMP_DIR}/${host}.success"
    local temp_file_failed="${TEMP_DIR}/${host}.failed"

    echo "$CMDLIST" | 
    ssh -l "$REMOTE_USER" -p "$REMOTE_PORT" "$SSH_ARGS" "$host" "$REMOTE_SHELL" \
        >>"$temp_file_success" 2>>"$temp_file_failed"

    rc="$?"
    if [[ "$rc" -eq 0 ]]; then
        if [[ -n "$VERBOSE" ]]; then
            #success "$host | success | rc=0 >>"
            tail -100 "$temp_file_success" | \
            awk -v host="$host" '{print "\033[32m1"host"\033[0m: "$0}'
        else
            success "$host | success | rc=0"
        fi
    else
        failed "$host | failed | rc=${rc} >>\n$(cat $temp_file_failed)"
    fi   
}


#并发控制
parall_run() {
    local module="${1:-ssh_cmd}"

    #建立命名管道文件，为了不受干扰，将文件打开，将文件inode信息删除
    local pipe="$(mktemp -u)" 
    mkfifo "$pipe" 
    #将文件$pipe绑定到文件描述符5 
    exec 5<>"$pipe"
    rm -f "$pipe" 

    #往命名管道存入值，存入多少个值就表示并发量多大
    for ((i=1;i<=${FORKS};i++)); do 
        echo >&5
    done 
  
    for host in ${HOSTLIST[@]}; do
        #从命名管道读取一个值
        #如果此时命名管道中没有值，read会阻塞直到读取到一个值  
        read -u 5
        #执行具体的动作，执行完后放入一个值到命名管道
        ($module "$host"; echo >&5) &
    done

    #等待所有后台进程执行完毕
    wait 
    #关闭文件描述符5
    exec 5>&-
}


cmdline_arguments_parse() {
    if [[ "$#" -lt 3 ]]; then
        usage
    fi

    #第一个参数必须为匹配模式字符串
    if [[ -n "$1" && "${1#-}" == "$1" ]]; then
        PATTERN="$1"
        shift
    else
        usage
    fi

    while getopts :m:a:b:h:u:p:s:i:f:o:v option; do
        case "$option" in
        m)
            MODULE="$OPTARG"
            ;;
        a)
            MODULE_ARGS="$OPTARG"
            #MODULE_ARGS+=($OPTARG)
            ;;
        b)
            BATCH_FILE="$OPTARG"
            ;;
        h)
            HOSTS_FILE="$OPTARG"
            ;;
        u)
            REMOTE_USER="$OPTARG"
            ;;
        p)
            REMOTE_PORT="$OPTARG"
            ;;
        s)
            REMOTE_SHELL="$OPTARG"
            ;;
        i)
            PRIVATE_KEY_FILE="$OPTARG"
            ;;
        f)
            FORKS="$OPTARG"
            ;;
        o)
            SSH_ARGS="$SSH_ARGS -o $OPTARG"
            ;;
        v)
            VERBOSE="yes"
            ;;
        \?)
            error "invalid option: -${OPTARG}"
            ;;
        \:)
            error "must provide a value for -${OPTARG} option"
            ;;
        esac
    done

    #OPTIND是全局变量，会影响到其他模块的getopts
    #每次通过getopts处理完选项后都要unset掉
    unset OPTIND
}


cmd() {
    CMDLIST="$CMDLIST
$@"
}


alive() {
    local host="$1"
    local ping_cmd=""
    #local temp_file_success="${TEMP_DIR}/${host}.success"
    local temp_file_failed="${TEMP_DIR}/${host}.failed"

    if which fping &>/dev/null; then
        ping_cmd="$(which fping)"
    else
        ping_cmd="$(which ping) -c 4 -q"
    fi

    $ping_cmd $host >/dev/null 2>"$temp_file_failed"
    local rc="$?"
    if [[ "$rc" -eq 0 ]]; then
        success "$host | success | rc=0"
    else
        failed "$host | failed | rc=${rc} >>\n$(cat $temp_file_failed)"
    fi
}


main() {
    #解析命令行参数
    cmdline_arguments_parse "$@"
    #解析hosts文件
    hostfile_parse
    #创建临时目录
    create_temp_dir

    if [[ -n "$MODULE" ]]; then
        #alive和scp_file都是本地执行的，属于特例
        if [[ "$MODULE" == "alive" || "$MODULE" == "scp_file" ]]; then
            parall_run "$MODULE"
            exit
        else
            $MODULE $MODULE_ARGS
        fi
    elif [[ -z "$MODULE" && -n "$MODULE_ARGS" ]]; then
        #如果不提供-m但是提供-a参数，则默认使用cmd模块
        cmd "$MODULE_ARGS"
    elif [[ -n "$BATCH_FILE" ]]; then
        . "$BATCH_FILE"
    else
        failed "nothing to do"
        usage
    fi

    #远程主机执行的命令列表不能为空
    [[ "${#CMDLIST}" -le 15 ]] && error "no command found"
    #并发执行命令
    parall_run
}


main "$@"

